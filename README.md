# WeiSuo Proxy

WeiSuo (pinyin of Chinese word: 猥瑣) is a network proxy implementation written in [Go](http://golang.org/),
with underlying protocol of [WebSocket](http://www.rfc-editor.org/rfc/rfc6455.txt).

## Why WebSocket?

WebSocket is a relatively simple protocol based on HTTP, that can easily tunnel TCP data stream.
Almost nothing need to be worried about, after a WebSocket connection is established.

Most of the modern CDN providers ([Cloudflare](https://www.cloudflare.com), [Amazon Cloudfront](https://aws.amazon.com/cloudfront/), etc...) have support
for WebSocket now, so we can hide our proxy servers behind the CDN.
Generally, ranges of IP addresses or domain names (e.g. xxxxx.cloudfront.net) of CDN providers are allowed by firewalls. It may be a good idea
to bypass firewalls using CDNs.

## Protocol

There are two types of connection in the protocol: common connection, and idle connection. It's determined by
client when initiating request.

### Common connection

Only HTTP headers are used to transmit metadata:

#### HTTP Request

Headers:
- ``X-PROXY-Authorization`` Authorization string, only static key is supported currently
- ``X-PROXY-Protocol`` Network protocol, only ``tcp`` is supported currently
- ``X-PROXY-Target`` Remote address to connect, e.g. ``192.168.1.1:8080``

#### HTTP Response

The HTTP connection should be upgraded to WebSocket,
otherwise a 4xx or 5xx status code with an error message would reveal why the server fails to handle the request.

Headers:
- ``X-PROXY-ID`` Unique request ID generated by ``xid``, used by logging only

### Idle connection

Idle connection is used to speed up connecting procedure. The connection becomes idle, after the HTTP connection is
upgraded to WebSocket.
Once a request (WebSocket message) is sent from client, the idle connection become active, the same as a common connection.

A connection is identified as an idle connection, only if some request headers are omitted.

#### HTTP Request

Headers:
- ``X-PROXY-Authorization`` Authorization string, only static key is supported currently
- ``X-PROXY-Protocol`` Network protocol, must be empty or omitted
- ``X-PROXY-Target`` Remote address to connect, must empty or omitted

#### HTTP Response

The HTTP connection should be upgraded to WebSocket,
otherwise a 4xx or 5xx status code with an error message would reveal why the server fails to handle the request.

Headers:
- ``X-PROXY-ID`` Unique request ID generated by ``xid``, used by logging only

#### WebSocket request message

- Message type: text
- Message content:
```json
{
  "protocol": "tcp",
  "target": "192.168.1.1:8080"
}
```

#### WebSocket response message

- Message type: text
- Message content: ``ok``

Otherwise, the message indicates why the server fails to handle the request.

### Data transmit

In a common connection or an active connection that was idle,
tunneling data is transmitted in binary WebSocket message without any other encapsulation.

An empty binary WebSocket message means that the other side closes writing (TCP half-close).

### WebSocket ping

WebSocket ping messages is required if the server is behind CDNs,
because CDNs would cut WebSocket connections if no message is transmitted within amount of time.

## Configurations

Configurations are stored in a JSON file, configuration keys below are required:
- ``mode`` Working mode. Since this project compiles to a single binary, 
this configuration key determines whether the running process is acting as a server or a client.
Check more details below.
- ``listen`` Address to listen, for example: ``127.0.0.1:8080``
- ``key`` Static authorization key
- ``endpoint`` Check more details below.

### Server

Mode should be ``server``.

Endpoint is the path that a client would access. If your value of endpoint is ``/proxy``,
the client would access the URL of ``wss://YOUR_DOMAIN_NAME/proxy``.

As a server, the process would provide HTTPS service by default,
so you have to provide a TLS certificate using two configuration keys: ``tls_cert``, ``tls_key``.

It's strongly discouraged to provide plain HTTP service. If you know what you are doing,
you can specify ``"insecure": true`` in the configuration file, then you can omit the two TLS
certificate configurations. But your authorization key and your payload will transmit without
encryption.

Example:
```json
{
  "mode": "server",
  "listen": "0.0.0.0:443",
  "key": "secured_password",
  "endpoint": "/proxy",
  "tls_cert": "/etc/ssl/private/example.com.pem",
  "tls_key": "/etc/ssl/private/example.com.key"
}
```

### Client

There are two implementation of client mode: ``client_http`` and ``client_nat``.

The configuration key ``endpoint`` is the URL that the client would access, e.g. ``wss://YOUR_DOMAIN_NAME/proxy``.

### HTTP proxy server

Client in ``client_http`` mode would act as an HTTP proxy server.

To speed up connection, you may specify a pool of idle connections, by using configuration key ``pool_size``.

Example:

```json
{
  "mode": "client_http",
  "listen": "127.0.0.1:8080",
  "key": "secured_password",
  "endpoint": "wss://YOUR_DOMAIN_NAME/proxy",
  "pool_size": 5
}
```

Then you may use this HTTP proxy server like this:

```shell
http_proxy=127.0.0.1:8080 curl http://example.com/
https_proxy=127.0.0.1:8080 curl https://www.google.com/
```

### Transparent proxy

Client in ``client_nat`` mode would act as a transparent proxy server.

Example:

```json
{
  "mode": "client_httpnat",
  "listen": "0.0.0.0:8989",
  "key": "secured_password",
  "endpoint": "wss://YOUR_DOMAIN_NAME/proxy"
}
```

Then you may add some firewall rules:

```shell
iptables -t nat -A PREROUTING -s 192.168.2.0/24 -p tcp -j REDIRECT --to-ports 8989
```

### Misc

#### Logging

To debug, you may specify key ``log_level``.
Valid values: ``no``, ``error``, ``warning``, ``info``, ``debug``. The default value is ``info``.

#### Speed test

As a server, you can provide speed test service by specifying ``"speedtest_endpoint": "/speedtest"``.
Then you can do some speed test like this:

```shell
# download 10 MB
time curl https://YOUR_DOMAIN_NAME/speedtest

# download 50 MB
time curl https://YOUR_DOMAIN_NAME/speedtest?size=50
```

Valid values of ``size``: ``10``, ``20``, ``30``, ``50``, ``100``. The unit is MB. Default value is ``10``.

#### Server presets

There may be CDNs in front of your server, and you cannot get the real IP address of clients.
You may specify ``server_preset`` in the configuration of a server, to get the real IP address
from the additional HTTP headers added by your CDN provider.

Currently, supported values: ``cloudflare``, ``aws_cloudfront``. Default value is empty.

#### Plain HTTP

As a client, you may use an insecure endpoint like ``ws://127.0.0.1/proxy`` by specifying ``"insecure": true``,
however it's strongly discouraged.

#### Custom DNS server

As a client, you may specify an address of custom DNS, to resolve the IP address of your endpoint. This can be useful,
if your default resolver does not reply the best DNS records of your CDN provider. And you will not mess up your
system configurations.

The configuration key is ``client_resolver``, and the format of value is ``protocol://ip_address:port``.
Valid protocols: ``udp``, ``tcp``.

Example: ``udp://127.0.0.1:5353``.

## Compiling and running

To compile:
```shell
go build
# Or use a docker
./docker_build.sh
```

To run:
```shell
./weisuo -config config.json
```

## Project dependencies

- [Gorilla WebSocket](https://github.com/gorilla/websocket) WebSocket implementation for client and server
- [xid](https://github.com/rs/xid) Unique ID generator, can be replaced by any other generator
